<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "https://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=9"/>
<meta name="generator" content="Doxygen 1.8.17"/>
<meta name="viewport" content="width=device-width, initial-scale=1"/>
<title>Point Cloud Library (PCL): pcl::detail Namespace Reference</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/searchdata.js"></script>
<script type="text/javascript" src="search/search.js"></script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr style="height: 56px;">
  <td id="projectalign" style="padding-left: 0.5em;">
   <div id="projectname">Point Cloud Library (PCL)
   &#160;<span id="projectnumber">1.11.1-dev</span>
   </div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.8.17 -->
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:cf05388f2679ee054f2beb29a391d25f4e673ac3&amp;dn=gpl-2.0.txt GPL-v2 */
var searchBox = new SearchBox("searchBox", "search",false,'Search');
/* @license-end */
</script>
<script type="text/javascript" src="menudata.js"></script>
<script type="text/javascript" src="menu.js"></script>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:cf05388f2679ee054f2beb29a391d25f4e673ac3&amp;dn=gpl-2.0.txt GPL-v2 */
$(function() {
  initMenu('',true,false,'search.php','Search');
  $(document).ready(function() { init_search(); });
});
/* @license-end */</script>
<div id="main-nav"></div>
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
</div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<iframe src="javascript:void(0)" frameborder="0" 
        name="MSearchResults" id="MSearchResults">
</iframe>
</div>

<div id="nav-path" class="navpath">
  <ul>
<li class="navelem"><a class="el" href="namespacepcl.html">pcl</a></li><li class="navelem"><a class="el" href="namespacepcl_1_1detail.html">detail</a></li>  </ul>
</div>
</div><!-- top -->
<div class="header">
  <div class="summary">
<a href="#nested-classes">Classes</a> &#124;
<a href="#typedef-members">Typedefs</a> &#124;
<a href="#func-members">Functions</a> &#124;
<a href="#var-members">Variables</a>  </div>
  <div class="headertitle">
<div class="title">pcl::detail Namespace Reference</div>  </div>
</div><!--header-->
<div class="contents">
<table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="nested-classes"></a>
Classes</h2></td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structpcl_1_1detail_1_1_accumulator_curvature.html">AccumulatorCurvature</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structpcl_1_1detail_1_1_accumulator_intensity.html">AccumulatorIntensity</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structpcl_1_1detail_1_1_accumulator_label.html">AccumulatorLabel</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structpcl_1_1detail_1_1_accumulator_normal.html">AccumulatorNormal</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structpcl_1_1detail_1_1_accumulator_r_g_b_a.html">AccumulatorRGBA</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structpcl_1_1detail_1_1_accumulators.html">Accumulators</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structpcl_1_1detail_1_1_accumulator_x_y_z.html">AccumulatorXYZ</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structpcl_1_1detail_1_1_add_point.html">AddPoint</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structpcl_1_1detail_1_1_copy_point_helper.html">CopyPointHelper</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structpcl_1_1detail_1_1_copy_point_helper_3_01_point_in_t_00_01_point_out_t_00_01std_1_1enable__c487bc3f47e9fe22c5163f2376baf88b.html">CopyPointHelper&lt; PointInT, PointOutT, std::enable_if_t&lt; boost::mpl::and_&lt; boost::mpl::not_&lt; std::is_same&lt; PointInT, PointOutT &gt; &gt;, boost::mpl::or_&lt; boost::mpl::and_&lt; pcl::traits::has_field&lt; PointInT, pcl::fields::rgb &gt;, pcl::traits::has_field&lt; PointOutT, pcl::fields::rgba &gt; &gt;, boost::mpl::and_&lt; pcl::traits::has_field&lt; PointInT, pcl::fields::rgba &gt;, pcl::traits::has_field&lt; PointOutT, pcl::fields::rgb &gt; &gt; &gt; &gt;::value &gt; &gt;</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structpcl_1_1detail_1_1_copy_point_helper_3_01_point_in_t_00_01_point_out_t_00_01std_1_1enable__52a079bdf5bb4f5832c5818670125948.html">CopyPointHelper&lt; PointInT, PointOutT, std::enable_if_t&lt; boost::mpl::and_&lt; boost::mpl::not_&lt; std::is_same&lt; PointInT, PointOutT &gt; &gt;, boost::mpl::or_&lt; boost::mpl::not_&lt; pcl::traits::has_color&lt; PointInT &gt; &gt;, boost::mpl::not_&lt; pcl::traits::has_color&lt; PointOutT &gt; &gt;, boost::mpl::and_&lt; pcl::traits::has_field&lt; PointInT, pcl::fields::rgb &gt;, pcl::traits::has_field&lt; PointOutT, pcl::fields::rgb &gt; &gt;, boost::mpl::and_&lt; pcl::traits::has_field&lt; PointInT, pcl::fields::rgba &gt;, pcl::traits::has_field&lt; PointOutT, pcl::fields::rgba &gt; &gt; &gt; &gt;::value &gt; &gt;</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structpcl_1_1detail_1_1_copy_point_helper_3_01_point_in_t_00_01_point_out_t_00_01std_1_1enable__ccc9392ccc4e3ffd8d6c96857f805506.html">CopyPointHelper&lt; PointInT, PointOutT, std::enable_if_t&lt; std::is_same&lt; PointInT, PointOutT &gt;::value &gt; &gt;</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structpcl_1_1detail_1_1_eigen_vector.html">EigenVector</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structpcl_1_1detail_1_1_field_adder.html">FieldAdder</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structpcl_1_1detail_1_1_field_mapper.html">FieldMapper</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structpcl_1_1detail_1_1_field_mapping.html">FieldMapping</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structpcl_1_1detail_1_1_get_point.html">GetPoint</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structpcl_1_1detail_1_1int__type.html">int_type</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight"><a class="el" href="structpcl_1_1detail_1_1int__type.html#a1d830b2bb47ff6fc4676c4b8d58b5962">int_type::type</a> refers to an integral type that satisfies template parameters  <a href="structpcl_1_1detail_1_1int__type.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structpcl_1_1detail_1_1int__type_3_0116_00_01false_01_4.html">int_type&lt; 16, false &gt;</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structpcl_1_1detail_1_1int__type_3_0116_00_01true_01_4.html">int_type&lt; 16, true &gt;</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structpcl_1_1detail_1_1int__type_3_0132_00_01false_01_4.html">int_type&lt; 32, false &gt;</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structpcl_1_1detail_1_1int__type_3_0132_00_01true_01_4.html">int_type&lt; 32, true &gt;</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structpcl_1_1detail_1_1int__type_3_0164_00_01false_01_4.html">int_type&lt; 64, false &gt;</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structpcl_1_1detail_1_1int__type_3_0164_00_01true_01_4.html">int_type&lt; 64, true &gt;</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structpcl_1_1detail_1_1int__type_3_018_00_01false_01_4.html">int_type&lt; 8, false &gt;</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structpcl_1_1detail_1_1int__type_3_018_00_01true_01_4.html">int_type&lt; 8, true &gt;</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structpcl_1_1detail_1_1_is_accumulator_compatible.html">IsAccumulatorCompatible</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structpcl_1_1detail_1_1_transformer.html">Transformer</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">A helper struct to apply an SO3 or SE3 transform to a 3D point.  <a href="structpcl_1_1detail_1_1_transformer.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="typedef-members"></a>
Typedefs</h2></td></tr>
<tr class="memitem:a3f3400ba40ee203c842481cfbb716900"><td class="memTemplParams" colspan="2">template&lt;std::size_t Bits, bool Signed = true&gt; </td></tr>
<tr class="memitem:a3f3400ba40ee203c842481cfbb716900"><td class="memTemplItemLeft" align="right" valign="top">using&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacepcl_1_1detail.html#a3f3400ba40ee203c842481cfbb716900">int_type_t</a> = typename <a class="el" href="structpcl_1_1detail_1_1int__type.html">int_type</a>&lt; Bits, Signed &gt;::type</td></tr>
<tr class="memdesc:a3f3400ba40ee203c842481cfbb716900"><td class="mdescLeft">&#160;</td><td class="mdescRight">helper type to use for <code><a class="el" href="structpcl_1_1detail_1_1int__type.html#a1d830b2bb47ff6fc4676c4b8d58b5962">int_type::type</a></code>  <a href="namespacepcl_1_1detail.html#a3f3400ba40ee203c842481cfbb716900">More...</a><br /></td></tr>
<tr class="separator:a3f3400ba40ee203c842481cfbb716900"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="func-members"></a>
Functions</h2></td></tr>
<tr class="memitem:af3842cf5d2a15a7d0d1a86da2e9ae4c6"><td class="memTemplParams" colspan="2">template&lt;typename Vector , typename Matrix &gt; </td></tr>
<tr class="memitem:af3842cf5d2a15a7d0d1a86da2e9ae4c6"><td class="memTemplItemLeft" align="right" valign="top">static <a class="el" href="structpcl_1_1detail_1_1_eigen_vector.html">EigenVector</a>&lt; Vector, typename Matrix::Scalar &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacepcl_1_1detail.html#af3842cf5d2a15a7d0d1a86da2e9ae4c6">getLargest3x3Eigenvector</a> (const Matrix scaledMatrix)</td></tr>
<tr class="memdesc:af3842cf5d2a15a7d0d1a86da2e9ae4c6"><td class="mdescLeft">&#160;</td><td class="mdescRight">returns the unit vector along the largest eigen value as well as the length of the largest eigenvector  <a href="namespacepcl_1_1detail.html#af3842cf5d2a15a7d0d1a86da2e9ae4c6">More...</a><br /></td></tr>
<tr class="separator:af3842cf5d2a15a7d0d1a86da2e9ae4c6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a24fe4be3441cd38cc1f9a8017bdd715f"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacepcl_1_1detail.html#a24fe4be3441cd38cc1f9a8017bdd715f">fieldOrdering</a> (const <a class="el" href="structpcl_1_1detail_1_1_field_mapping.html">FieldMapping</a> &amp;a, const <a class="el" href="structpcl_1_1detail_1_1_field_mapping.html">FieldMapping</a> &amp;b)</td></tr>
<tr class="separator:a24fe4be3441cd38cc1f9a8017bdd715f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a93b2338236d3a301bf2e82477fd6d197"><td class="memTemplParams" colspan="2">template&lt;typename Type &gt; </td></tr>
<tr class="memitem:a93b2338236d3a301bf2e82477fd6d197"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacepcl_1_1detail.html#a93b2338236d3a301bf2e82477fd6d197">copyStringValue</a> (const std::string &amp;st, <a class="el" href="structpcl_1_1_p_c_l_point_cloud2.html">pcl::PCLPointCloud2</a> &amp;cloud, <a class="el" href="namespacepcl.html#a45edbae979af563e6a1e39fd1aad3911">pcl::index_t</a> point_index, unsigned int field_idx, unsigned int fields_count, std::istringstream &amp;is)</td></tr>
<tr class="separator:a93b2338236d3a301bf2e82477fd6d197"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a317c73abbd065aad8bb740cc0da80b34"><td class="memItemLeft" align="right" valign="top">template&lt;&gt; </td></tr>
<tr class="memitem:a317c73abbd065aad8bb740cc0da80b34"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacepcl_1_1detail.html#a317c73abbd065aad8bb740cc0da80b34">copyStringValue&lt; std::int8_t &gt;</a> (const std::string &amp;st, <a class="el" href="structpcl_1_1_p_c_l_point_cloud2.html">pcl::PCLPointCloud2</a> &amp;cloud, <a class="el" href="namespacepcl.html#a45edbae979af563e6a1e39fd1aad3911">pcl::index_t</a> point_index, unsigned int field_idx, unsigned int fields_count, std::istringstream &amp;is)</td></tr>
<tr class="separator:a317c73abbd065aad8bb740cc0da80b34"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af68168a03f7fa557abf6d48a62ce2151"><td class="memItemLeft" align="right" valign="top">template&lt;&gt; </td></tr>
<tr class="memitem:af68168a03f7fa557abf6d48a62ce2151"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacepcl_1_1detail.html#af68168a03f7fa557abf6d48a62ce2151">copyStringValue&lt; std::uint8_t &gt;</a> (const std::string &amp;st, <a class="el" href="structpcl_1_1_p_c_l_point_cloud2.html">pcl::PCLPointCloud2</a> &amp;cloud, <a class="el" href="namespacepcl.html#a45edbae979af563e6a1e39fd1aad3911">pcl::index_t</a> point_index, unsigned int field_idx, unsigned int fields_count, std::istringstream &amp;is)</td></tr>
<tr class="separator:af68168a03f7fa557abf6d48a62ce2151"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="var-members"></a>
Variables</h2></td></tr>
<tr class="memitem:a485d0d8c7a7b9981ac9e76ab821a38e4"><td class="memItemLeft" align="right" valign="top">constexpr std::uint8_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacepcl_1_1detail.html#a485d0d8c7a7b9981ac9e76ab821a38e4">index_type_size</a> = PCL_INDEX_SIZE</td></tr>
<tr class="memdesc:a485d0d8c7a7b9981ac9e76ab821a38e4"><td class="mdescLeft">&#160;</td><td class="mdescRight">number of bits in PCL's index type  <a href="namespacepcl_1_1detail.html#a485d0d8c7a7b9981ac9e76ab821a38e4">More...</a><br /></td></tr>
<tr class="separator:a485d0d8c7a7b9981ac9e76ab821a38e4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0d5f9ba23dbec1366c9021dc149c9925"><td class="memItemLeft" align="right" valign="top">constexpr bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacepcl_1_1detail.html#a0d5f9ba23dbec1366c9021dc149c9925">index_type_signed</a> = PCL_INDEX_SIGNED</td></tr>
<tr class="memdesc:a0d5f9ba23dbec1366c9021dc149c9925"><td class="mdescLeft">&#160;</td><td class="mdescRight">signed/unsigned nature of PCL's index type Please use PCL_INDEX_SIGNED when building PCL to choose a type best suited for your needs.  <a href="namespacepcl_1_1detail.html#a0d5f9ba23dbec1366c9021dc149c9925">More...</a><br /></td></tr>
<tr class="separator:a0d5f9ba23dbec1366c9021dc149c9925"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table>
<h2 class="groupheader">Typedef Documentation</h2>
<a id="a3f3400ba40ee203c842481cfbb716900"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a3f3400ba40ee203c842481cfbb716900">&#9670;&nbsp;</a></span>int_type_t</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;std::size_t Bits, bool Signed = true&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">using <a class="el" href="namespacepcl_1_1detail.html#a3f3400ba40ee203c842481cfbb716900">pcl::detail::int_type_t</a> = typedef typename <a class="el" href="structpcl_1_1detail_1_1int__type.html">int_type</a>&lt;Bits, Signed&gt;::type</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>helper type to use for <code><a class="el" href="structpcl_1_1detail_1_1int__type.html#a1d830b2bb47ff6fc4676c4b8d58b5962">int_type::type</a></code> </p>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="structpcl_1_1detail_1_1int__type.html" title="int_type::type refers to an integral type that satisfies template parameters">int_type</a> </dd></dl>

<p class="definition">Definition at line <a class="el" href="types_8h_source.html#l00068">68</a> of file <a class="el" href="types_8h_source.html">types.h</a>.</p>

</div>
</div>
<h2 class="groupheader">Function Documentation</h2>
<a id="a93b2338236d3a301bf2e82477fd6d197"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a93b2338236d3a301bf2e82477fd6d197">&#9670;&nbsp;</a></span>copyStringValue()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Type &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void pcl::detail::copyStringValue </td>
          <td>(</td>
          <td class="paramtype">const std::string &amp;&#160;</td>
          <td class="paramname"><em>st</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structpcl_1_1_p_c_l_point_cloud2.html">pcl::PCLPointCloud2</a> &amp;&#160;</td>
          <td class="paramname"><em>cloud</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="namespacepcl.html#a45edbae979af563e6a1e39fd1aad3911">pcl::index_t</a>&#160;</td>
          <td class="paramname"><em>point_index</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">unsigned int&#160;</td>
          <td class="paramname"><em>field_idx</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">unsigned int&#160;</td>
          <td class="paramname"><em>fields_count</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::istringstream &amp;&#160;</td>
          <td class="paramname"><em>is</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p class="definition">Definition at line <a class="el" href="io_2include_2pcl_2io_2file__io_8h_source.html#l00330">330</a> of file <a class="el" href="io_2include_2pcl_2io_2file__io_8h_source.html">file_io.h</a>.</p>

<p class="reference">References <a class="el" href="_p_c_l_point_cloud2_8h_source.html#l00030">pcl::PCLPointCloud2::data</a>, <a class="el" href="_p_c_l_point_cloud2_8h_source.html#l00023">pcl::PCLPointCloud2::fields</a>, <a class="el" href="_p_c_l_point_cloud2_8h_source.html#l00032">pcl::PCLPointCloud2::is_dense</a>, and <a class="el" href="_p_c_l_point_cloud2_8h_source.html#l00027">pcl::PCLPointCloud2::point_step</a>.</p>

</div>
</div>
<a id="a317c73abbd065aad8bb740cc0da80b34"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a317c73abbd065aad8bb740cc0da80b34">&#9670;&nbsp;</a></span>copyStringValue&lt; std::int8_t &gt;()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="namespacepcl_1_1detail.html#a93b2338236d3a301bf2e82477fd6d197">pcl::detail::copyStringValue</a>&lt; std::int8_t &gt; </td>
          <td>(</td>
          <td class="paramtype">const std::string &amp;&#160;</td>
          <td class="paramname"><em>st</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structpcl_1_1_p_c_l_point_cloud2.html">pcl::PCLPointCloud2</a> &amp;&#160;</td>
          <td class="paramname"><em>cloud</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="namespacepcl.html#a45edbae979af563e6a1e39fd1aad3911">pcl::index_t</a>&#160;</td>
          <td class="paramname"><em>point_index</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">unsigned int&#160;</td>
          <td class="paramname"><em>field_idx</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">unsigned int&#160;</td>
          <td class="paramname"><em>fields_count</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::istringstream &amp;&#160;</td>
          <td class="paramname"><em>is</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p class="definition">Definition at line <a class="el" href="io_2include_2pcl_2io_2file__io_8h_source.html#l00356">356</a> of file <a class="el" href="io_2include_2pcl_2io_2file__io_8h_source.html">file_io.h</a>.</p>

<p class="reference">References <a class="el" href="_p_c_l_point_cloud2_8h_source.html#l00030">pcl::PCLPointCloud2::data</a>, <a class="el" href="_p_c_l_point_cloud2_8h_source.html#l00023">pcl::PCLPointCloud2::fields</a>, and <a class="el" href="_p_c_l_point_cloud2_8h_source.html#l00027">pcl::PCLPointCloud2::point_step</a>.</p>

</div>
</div>
<a id="af68168a03f7fa557abf6d48a62ce2151"></a>
<h2 class="memtitle"><span class="permalink"><a href="#af68168a03f7fa557abf6d48a62ce2151">&#9670;&nbsp;</a></span>copyStringValue&lt; std::uint8_t &gt;()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="namespacepcl_1_1detail.html#a93b2338236d3a301bf2e82477fd6d197">pcl::detail::copyStringValue</a>&lt; std::uint8_t &gt; </td>
          <td>(</td>
          <td class="paramtype">const std::string &amp;&#160;</td>
          <td class="paramname"><em>st</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structpcl_1_1_p_c_l_point_cloud2.html">pcl::PCLPointCloud2</a> &amp;&#160;</td>
          <td class="paramname"><em>cloud</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="namespacepcl.html#a45edbae979af563e6a1e39fd1aad3911">pcl::index_t</a>&#160;</td>
          <td class="paramname"><em>point_index</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">unsigned int&#160;</td>
          <td class="paramname"><em>field_idx</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">unsigned int&#160;</td>
          <td class="paramname"><em>fields_count</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::istringstream &amp;&#160;</td>
          <td class="paramname"><em>is</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p class="definition">Definition at line <a class="el" href="io_2include_2pcl_2io_2file__io_8h_source.html#l00380">380</a> of file <a class="el" href="io_2include_2pcl_2io_2file__io_8h_source.html">file_io.h</a>.</p>

<p class="reference">References <a class="el" href="_p_c_l_point_cloud2_8h_source.html#l00030">pcl::PCLPointCloud2::data</a>, <a class="el" href="_p_c_l_point_cloud2_8h_source.html#l00023">pcl::PCLPointCloud2::fields</a>, and <a class="el" href="_p_c_l_point_cloud2_8h_source.html#l00027">pcl::PCLPointCloud2::point_step</a>.</p>

</div>
</div>
<a id="a24fe4be3441cd38cc1f9a8017bdd715f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a24fe4be3441cd38cc1f9a8017bdd715f">&#9670;&nbsp;</a></span>fieldOrdering()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool pcl::detail::fieldOrdering </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="structpcl_1_1detail_1_1_field_mapping.html">FieldMapping</a> &amp;&#160;</td>
          <td class="paramname"><em>a</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="structpcl_1_1detail_1_1_field_mapping.html">FieldMapping</a> &amp;&#160;</td>
          <td class="paramname"><em>b</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p class="definition">Definition at line <a class="el" href="conversions_8h_source.html#l00115">115</a> of file <a class="el" href="conversions_8h_source.html">conversions.h</a>.</p>

<p class="reference">References <a class="el" href="common_2include_2pcl_2point__cloud_8h_source.html#l00063">pcl::detail::FieldMapping::serialized_offset</a>.</p>

<p class="reference">Referenced by <a class="el" href="conversions_8h_source.html#l00123">pcl::createMapping()</a>.</p>

</div>
</div>
<a id="af3842cf5d2a15a7d0d1a86da2e9ae4c6"></a>
<h2 class="memtitle"><span class="permalink"><a href="#af3842cf5d2a15a7d0d1a86da2e9ae4c6">&#9670;&nbsp;</a></span>getLargest3x3Eigenvector()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Vector , typename Matrix &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static <a class="el" href="structpcl_1_1detail_1_1_eigen_vector.html">EigenVector</a>&lt;Vector, typename Matrix::Scalar&gt; pcl::detail::getLargest3x3Eigenvector </td>
          <td>(</td>
          <td class="paramtype">const Matrix&#160;</td>
          <td class="paramname"><em>scaledMatrix</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>returns the unit vector along the largest eigen value as well as the length of the largest eigenvector </p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">Vector</td><td>Requested result type, needs to be explicitly provided and has to be implicitly constructible from ConstRowExpr </td></tr>
    <tr><td class="paramname">Matrix</td><td>deduced input type providing similar in API as Eigen::Matrix </td></tr>
  </table>
  </dd>
</dl>

<p class="definition">Definition at line <a class="el" href="common_2include_2pcl_2common_2impl_2eigen_8hpp_source.html#l00273">273</a> of file <a class="el" href="common_2include_2pcl_2common_2impl_2eigen_8hpp_source.html">eigen.hpp</a>.</p>

</div>
</div>
<h2 class="groupheader">Variable Documentation</h2>
<a id="a0d5f9ba23dbec1366c9021dc149c9925"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a0d5f9ba23dbec1366c9021dc149c9925">&#9670;&nbsp;</a></span>index_type_signed</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">constexpr bool pcl::detail::index_type_signed = PCL_INDEX_SIGNED</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">constexpr</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>signed/unsigned nature of PCL's index type Please use PCL_INDEX_SIGNED when building PCL to choose a type best suited for your needs. </p>
<p>Default: signed </p>

<p class="definition">Definition at line <a class="el" href="types_8h_source.html#l00102">102</a> of file <a class="el" href="types_8h_source.html">types.h</a>.</p>

</div>
</div>
<a id="a485d0d8c7a7b9981ac9e76ab821a38e4"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a485d0d8c7a7b9981ac9e76ab821a38e4">&#9670;&nbsp;</a></span>index_type_size</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">constexpr std::uint8_t pcl::detail::index_type_size = PCL_INDEX_SIZE</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">constexpr</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>number of bits in PCL's index type </p>
<p>Please use PCL_INDEX_SIZE when building PCL to choose a size best suited for your needs. PCL 1.12 will come with default 32</p>
<p>PCL 1.11 has a default size = sizeof(int) </p>

<p class="definition">Definition at line <a class="el" href="types_8h_source.html#l00095">95</a> of file <a class="el" href="types_8h_source.html">types.h</a>.</p>

</div>
</div>
</div><!-- contents -->
<hr>
<div id="footer">
<p>
Except where otherwise noted, the PointClouds.org web pages are licensed under <a href="http://creativecommons.org/licenses/by/3.0/">Creative Commons Attribution 3.0</a>. 
</p>
<p>Pages generated on Sun Dec 20 2020 13:21:43</p>
</div> <!-- #footer -->
</body>
</html>
